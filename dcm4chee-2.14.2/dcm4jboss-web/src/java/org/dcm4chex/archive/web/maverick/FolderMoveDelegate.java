/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is part of dcm4che, an implementation of DICOM(TM) in
 * Java(TM), available at http://sourceforge.net/projects/dcm4che.
 *
 * The Initial Developer of the Original Code is
 * TIANI Medgraph AG.
 * Portions created by the Initial Developer are Copyright (C) 2003-2005
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 * Gunter Zeilinger <gunter.zeilinger@tiani.com>
 * Franz Willer <franz.willer@gwi-ag.com>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

package org.dcm4chex.archive.web.maverick;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import org.dcm4che.data.Dataset;
import org.dcm4che.data.DcmObjectFactory;
import org.dcm4che.dict.Tags;
import org.dcm4che.util.UIDGenerator;
import org.dcm4chex.archive.ejb.interfaces.ContentManager;
import org.dcm4chex.archive.ejb.interfaces.ContentManagerHome;
import org.dcm4chex.archive.util.EJBHomeFactory;
import org.dcm4chex.archive.web.maverick.model.AbstractModel;
import org.dcm4chex.archive.web.maverick.model.InstanceModel;
import org.dcm4chex.archive.web.maverick.model.PatientModel;
import org.dcm4chex.archive.web.maverick.model.SeriesModel;
import org.dcm4chex.archive.web.maverick.model.StudyModel;

/**
 * @author franz.willer
 *
 * TODO To change the template for this generated type comment go to
 * Window - Preferences - Java - Code Style - Code Templates
 */
public class FolderMoveDelegate {

	private static final String AUTO_GENERATED_BY_MOVE_TEXT = "Auto-generated by move";
	public static final int MOVE_ERROR = -1;
	public static final int PATIENT = 0;
	public static final int STUDY = 1;
	public static final int SERIES = 2;
	public static final int INSTANCE = 3;

	private FolderSubmitCtrl ctrl;
    private ContentEditDelegate delegate;
    private FolderForm folderForm;
    
    private static final DcmObjectFactory dof = DcmObjectFactory.getInstance();
    
	
	public FolderMoveDelegate( FolderSubmitCtrl ctrl ) {
		this.ctrl = ctrl;
		delegate = FolderSubmitCtrl.getDelegate();
	}
    /**
     * Move one ore more model instances to another parent.
     * <p>
     * The move is restricted with following rules:<br>
     * 1) the destinations model type must be the same as the source parents model type.<br>
     * 2) the destination must be different to the source parent.<br>
     * 3) all source models must have the same parent.<br>
     * 4) the destination and the source parent must have the same parent.<br>
     * 
     * @return the name of the next view.
     */
    public boolean move() {
    	folderForm = (FolderForm) ctrl.getForm();
    	int[] srcDest = getSrcAndDest( folderForm.getStickyPatients(),
    								 folderForm.getStickyStudies(),
    								 folderForm.getStickySeries(),
    								 folderForm.getStickyInstances()
    								);
    	int moveType = srcDest[0];
    	boolean ret = false;

    	if ( moveType != MOVE_ERROR) {
    		if (! this.checkStickyPlacement(srcDest[0], srcDest[1]) ) return false;
    		
    		int iDest = srcDest[1];
    		ContentManager cm = null;
    		try {
    			ContentManagerHome home = (ContentManagerHome) EJBHomeFactory
		        .getFactory().lookup(ContentManagerHome.class,
		                ContentManagerHome.JNDI_NAME);
		        cm = home.create();
    			
	    		if ( moveType == STUDY ) {
	    			_move_studies( cm );
	    		} else if ( moveType == SERIES ) {
	    			_move_series( cm, iDest );
	    		} else if ( moveType == INSTANCE ) {
	    			_move_instances( cm, iDest );
	    		}
	    		ctrl.clearSticky();
	    		ret = true;
    		} catch ( Exception x ) {
        		folderForm.setPopupMsg("folder.err_move", x.getMessage() );
    		}	finally {
    	            try {
    	            	if ( cm != null )
    	            		cm.remove();
    	            } catch (Exception e) {
    	            }
    		}
    	}
		return ret;
    }

    
	/**
     * Move selected studies to a patient.
     * 
	 * @param cm ContentManagerBean to update the model.
	 */
	private void _move_studies( ContentManager cm ) throws Exception {
		long iDest = Long.parseLong( (String) folderForm.getStickyPatients().iterator().next().toString() );
		long[] iaSrc = getLongArrayFromSet( folderForm.getStickyStudies() );
		delegate.moveStudies( iaSrc, iDest );
		
		PatientModel destPat = folderForm.getPatientByPk( iDest );
		List path = findModelPath( folderForm.getPatients(), iaSrc[0], 1 );
		PatientModel srcPat = (PatientModel) path.get(0);
		_updatePatientWithStudies( destPat, cm );
		_updatePatientWithStudies( srcPat, cm );
		StudyModel study;
		for ( int i = 0, len=iaSrc.length ; i < len ; i++ ) {
			study = new StudyModel( cm.getStudy( iaSrc[i] ) );
	        ctrl.logProcedureRecord(destPat,study,"study moved from " + srcPat.getPatientName()+ 
	        		" ("+srcPat.getPatientID()+")" );
		}
	}
	
	private void _move_series( ContentManager cm, int dest ) throws Exception {
		long iDestStdy = -1, iDestPat = -1;
		if ( dest == STUDY ) {
			iDestStdy = Integer.parseInt( folderForm.getStickyStudies().iterator().next().toString() );
		} else {
			iDestPat = Integer.parseInt( folderForm.getStickyPatients().iterator().next().toString() );
		}
		long[] iaSrc = getLongArrayFromSet( folderForm.getStickySeries() );
		
		List sourcePath = findModelPath( folderForm.getPatients(), iaSrc[0], 2 );
		StudyModel srcStudy = (StudyModel) sourcePath.get(1);//0..patient,1..study,2..series

		StudyModel destStudy;
		PatientModel pat;
		if ( iDestStdy != -1 ) {
			List destPath = findModelPath( folderForm.getPatients(), iDestStdy, 1 );
			destStudy = (StudyModel) destPath.get(1);
			pat = (PatientModel) destPath.get(0);
		} else {
			List destPath = findModelPath( folderForm.getPatients(), iDestPat, 0 );
			pat = (PatientModel) destPath.get(0);
			destStudy = new StudyModel( delegate.createStudy(getStudyDS(srcStudy), pat.getPk() ) );
			pat.getStudies().add(destStudy);
			iDestStdy = destStudy.getPk();
		}
		delegate.moveSeries( iaSrc, iDestStdy );
		//update model for view
		_updateStudyWithSeries( destStudy, cm );
		_updateStudyWithSeries( srcStudy, cm );
		//audit log for source study
		ctrl.logProcedureRecord(pat,srcStudy,iaSrc.length + " series moved to " + 
				destStudy.getStudyDescription()+ " ("+destStudy.getStudyIUID()+")");
		//audit log for destination study
		ctrl.logProcedureRecord(pat,destStudy,iaSrc.length + " series moved from " + 
				srcStudy.getStudyDescription()+ " ("+srcStudy.getStudyIUID()+")");
	}
	
	private void _move_instances( ContentManager cm, int dest ) throws Exception {
		long iDestSeries = -1,iDestStdy = -1, iDestPat = -1;
		if ( dest == SERIES ) {
			iDestSeries = Integer.parseInt( (String) folderForm.getStickySeries().iterator().next().toString() );
		} else if ( dest == STUDY ) {
			iDestStdy = Integer.parseInt( (String) folderForm.getStickyStudies().iterator().next().toString() );
		} else {
			iDestPat = Integer.parseInt( (String) folderForm.getStickyPatients().iterator().next().toString() );
		}
		long[] iaSrc = getLongArrayFromSet( folderForm.getStickyInstances() );

		List sourcePath = findModelPath( folderForm.getPatients(), iaSrc[0], 3 );
		StudyModel srcStudy = (StudyModel) sourcePath.get(1);//0..patient,1..study,2..series
		SeriesModel srcSeries = (SeriesModel) sourcePath.get(2);//0..patient,1..study,2..series
		
		SeriesModel destSeries;
		StudyModel destStudy = null;
		PatientModel pat;
		if ( iDestSeries != -1 ) {
			List destPath = findModelPath( folderForm.getPatients(), iDestSeries, 2 );
			destSeries = (SeriesModel) destPath.get(2);//0..patient,1..study,2..series
			pat = (PatientModel) destPath.get(0);
		} else {
			if ( iDestStdy != -1 ) {
				List destPath = findModelPath( folderForm.getPatients(), iDestStdy, 1 );
				destStudy = (StudyModel) destPath.get(1);
				pat = (PatientModel) destPath.get(0);
				destSeries = new SeriesModel(delegate.createSeries(getSeriesDS(srcSeries), iDestStdy));
				destStudy.getSeries().add(destSeries);
			} else {
				List destPath = findModelPath( folderForm.getPatients(), iDestPat, 0 );
				pat = (PatientModel) destPath.get(0);
				destStudy = new StudyModel( delegate.createStudy(getStudyDS(srcStudy), pat.getPk() ) );
				pat.getStudies().add(destStudy);
				destSeries = new SeriesModel(delegate.createSeries(getSeriesDS(srcSeries), destStudy.getPk()));
				destStudy.getSeries().add(destSeries);
			}
			iDestSeries = destSeries.getPk();
		}
		delegate.moveInstances( iaSrc, iDestSeries );

		_updateSeriesWithInstances( destSeries, cm );
		_updateSeriesWithInstances( (SeriesModel) sourcePath.get(2), cm );//0..patient,1..study,2..series,3..instances

		if ( destStudy != null ) destStudy.update( cm.getStudy( destStudy.getPk() ) );
/*_*/	
		ctrl.logProcedureRecord(pat,srcStudy,iaSrc.length + " instances moved to " + 
				destSeries.getSeriesDescription()+ " ("+destSeries.getSeriesIUID()+")");
	}
//*********** dummy datasets for series/study creation
	
    /**
	 * @param srcSeries
     * @param modality
     * @return
	 */
	private Dataset getSeriesDS(SeriesModel srcSeries) {
		Dataset ds = dof.newDataset();
		ds.putCS(Tags.SpecificCharacterSet, "ISO_IR 100");
		ds.putUI(Tags.SeriesInstanceUID, UIDGenerator.getInstance().createUID() );
		String desc;
		if ( srcSeries == null ) {
			desc = AUTO_GENERATED_BY_MOVE_TEXT;
		} else {
			desc = srcSeries.getSeriesDescription();
			desc = desc == null ? AUTO_GENERATED_BY_MOVE_TEXT:desc+" ("+AUTO_GENERATED_BY_MOVE_TEXT+")";
			Dataset dsSrc = srcSeries.toDataset();
			ds.putDA(Tags.SeriesDate, dsSrc.getDate(Tags.SeriesDate) );
			ds.putTM(Tags.SeriesTime, dsSrc.getDate(Tags.SeriesTime) );
			ds.putCS(Tags.Modality, dsSrc.getString(Tags.Modality));
		}
		ds.putLO(Tags.SeriesDescription,desc);
		return ds;
	}

	/**
	 * @param modality
	 * @return
	 */
	private Dataset getStudyDS(StudyModel srcStudy) {
		Dataset ds = dof.newDataset();
		ds.putCS(Tags.SpecificCharacterSet, "ISO_IR 100");
		ds.putUI(Tags.StudyInstanceUID, UIDGenerator.getInstance().createUID() );
		String desc;
		if ( srcStudy == null ) {
			desc = AUTO_GENERATED_BY_MOVE_TEXT;
		} else {
			desc = srcStudy.getStudyDescription();
			desc = desc == null ? AUTO_GENERATED_BY_MOVE_TEXT:desc+" ("+AUTO_GENERATED_BY_MOVE_TEXT+")";
			Dataset dsSrc = srcStudy.toDataset();
			ds.putDA(Tags.StudyDate, dsSrc.getDate(Tags.StudyDate) );
			ds.putTM(Tags.StudyTime, dsSrc.getDate(Tags.StudyTime) );
			ds.putCS(Tags.ModalitiesInStudy, dsSrc.getStrings(Tags.ModalitiesInStudy));
		}
		ds.putLO(Tags.StudyDescription,desc);
		return ds;
	}

//*********** update model for view	
	private void _updateStudyWithSeries(StudyModel study, ContentManager cm) throws Exception {
		List series = cm.listSeriesOfStudy( study.getPk() );
        for (int i = 0, n = series.size(); i < n; i++)
        	series.set(i, new SeriesModel((Dataset) series.get(i)));
        study.setSeries( series );
        study.update( cm.getStudy( study.getPk() ) );
	}
    /**
     * update given patient with studies.
     * 
	 * @param patient Patient.
	 * @param cm ContentManagerBean to get current list of studies.
	 */
	private void _updatePatientWithStudies( PatientModel patient, ContentManager cm ) throws Exception {
		List studies = cm.listStudiesOfPatient( patient.getPk() );
        for (int i = 0, n = studies.size(); i < n; i++)
            studies.set(i, new StudyModel((Dataset) studies.get(i)));
        patient.setStudies( studies );
	}
	private void _updateSeriesWithInstances(SeriesModel series, ContentManager cm) throws Exception {
		List inst = cm.listInstancesOfSeries( series.getPk() );
        for (int i = 0, n = inst.size(); i < n; i++)
        	inst.set(i, InstanceModel.valueOf((Dataset) inst.get(i)));
        series.setInstances( inst );
        series.update( cm.getSeries( series.getPk() ) );
	}

	
	/**
	 * Checks the numbers of selected stickies to get moveMode.
	 * <p>
	 * This method checks if only one destination, one ore more sources and no other stickies are set.
	 * <p>
	 * If one of the following rules are not fullfilled, a corresponding error code is set in FolderForms.
	 * <DL>
	 * <DT>Rule:</DT>
	 * <DD>  iDest must be 1</DD>
	 * <DD>  one of iSrcStudy, iSrcSeries or iSrcInstance must be greater than 0</DD>
	 * <DD>  all other have to be 0</DD>
	 * </DL>
	 * 
	 * @param iDest			Number of selected destinations
	 * @param iSrcStudy		Number of selected sources study level
	 * @param iSrcSeries	Number of selected sources series level
	 * @param iSrcInstance	Number of selected sources instance level
	 * 
	 * @return The move mode or MOVE_ERROR.
	 */
	private int[] getSrcAndDest( Set stickyPat, Set stickyStudy, Set stickySeries, Set stickyInstance ) {
    	int dest = MOVE_ERROR;
    	int src = MOVE_ERROR;
    	int mask = (stickyPat.isEmpty() ? 0:8) | 
    			   (stickyStudy.isEmpty() ? 0:4) | 
    			   (stickySeries.isEmpty() ? 0:2) | 
    			   (stickyInstance.isEmpty() ? 0:1);
    	switch ( mask ) {
		case 0x09:
			dest = PATIENT;
			src = INSTANCE;
			break;
		case 0x0A:
			dest = PATIENT;
			src = SERIES;
			break;
		case 0x0C:
			dest = PATIENT;
			src = STUDY;
			break;
    		
		case 0x05:
			dest = STUDY;
			src = INSTANCE;
			break;
		case 0x06:
			dest = STUDY;
			src = SERIES;
			break;
		case 0x03:
			dest = SERIES;
			src = INSTANCE;
			break;
			
		case 0x00:
			folderForm.setPopupMsg( "folder.err_move_no_selection", "" );
			break;
		default:
            folderForm.setPopupMsg( "folder.err_move_no_source", "" );
    	}
    	return new int[]{src,dest};
 	}
    
    /**
     * Checks if the sticky informations are at correct positions.
     * <p>
     * This method checks following restrictions:<br>
     * 1) Only one destination must be selected.
     * 2) the destination must be different to the source parent.<br>
     * 3) all source models must have the same parent.<br>
     * <p>
     * If one of the checks failed a corresponding error code is set in FolderForms.
     * 
     * @param stickySrc Sticky information of the childs (the source).
     * @param stickyDest Sticky information of the parent (the destination).
     * @return
     */
    private boolean checkStickyPlacement( int src, int dest ) {
		Set stickyDst = getStickies( dest );
		if ( stickyDst.size() > 1) {
            folderForm.setPopupMsg( "folder.err_move_toManyDest", "" );
			return false;
		} 
		Set stickySrc = getStickies( src );
		List listDst = findModelPath( folderForm.getPatients(), (String)stickyDst.iterator().next(), dest );
		List listSrc = findModelPath( folderForm.getPatients(), (String)stickySrc.iterator().next(), src );
		int listParentSize = listDst.size()-1;
		if ( listDst.get(listParentSize).equals( listSrc.get(listSrc.size()-1) ) ) {
			if ( src == STUDY)
                folderForm.setPopupMsg( "folder.err_move_samePatient", "" );
			else if ( src == SERIES)
                folderForm.setPopupMsg( "folder.err_move_sameStudy", "" );
			else if ( src == INSTANCE)
                folderForm.setPopupMsg( "folder.err_move_sameSeries", "" );
			return false; //same parent;
		}
		AbstractModel model = (AbstractModel) listSrc.get(listSrc.size()-2);//parent model of first child
		Iterator iter = stickySrc.iterator();
		iter.next(); //skip first element (is used for listChilds)
		while ( iter.hasNext() ) {
			if ( !model.containsPK( Long.valueOf( iter.next().toString() ) ) ) {
				if ( src == STUDY)
                    folderForm.setPopupMsg( "folder.err_move_diffStudyParent", "" );
				else if ( src == SERIES)
                    folderForm.setPopupMsg( "folder.err_move_diffSeriesParent", "" );
				else if ( src == INSTANCE)
                    folderForm.setPopupMsg( "folder.err_move_diffInstanceParent", "" );
				return false; //this child has not the same parent as first child element
			}
		}
 		return true;
    }

	
	/**
     * Converts a Set of int values as String to an int array.
     * 
	 * @param set Set with String objects of int
	 * @return int Array
	 */
	public static long[] getLongArrayFromSet(Set set) {
		if ( set == null ) return null;
		long[] ia = new long[ set.size() ];
		int i = 0;
		for ( Iterator iter = set.iterator() ; iter.hasNext() ; i++ ) {
			ia[i] = Long.parseLong( (String) iter.next() );
		}
		return ia;
	}

    
	/**
	 * Returns the tree nodes for a given pk.
	 * <p>
	 * Because the pk's are only unique within a model type, it is necessary to use the correct
	 * depth value!
	 * <p>
	 * 
	 * @param parent 	This is the root model of the tree to search.
	 * @param pk		The pk as String to search
	 * @param depth		The tree depth where the pk should be found.
	 * @return A list with all nodes to get the model.
	 */
    private List findModelPath( List parent, String pk, int depth ) {
       	long lPk = Long.parseLong(pk);
   	    return findModelPath( parent, lPk, depth );
    }
 
	/**
	 * Returns the tree nodes for a given pk.
	 * <p>
	 * Because the pk's are only unique within a model type, it is necessary to use the correct
	 * depth value!
	 * <p>
	 * 
	 * @param parent 	This is the root model of the tree to search.
	 * @param pk		The pk as int to search
	 * @param depth		The tree depth where the pk should be found.
	 * @return A list with all nodes to get the model.
	 */
    private List findModelPath( List parent, long pk, int depth ) {
    	Iterator iter = parent.iterator();
    	AbstractModel model = null;
    	List l = new ArrayList();
    	while ( iter.hasNext() ) {
    		model = (AbstractModel) iter.next();
    		if ( depth == 0 ) {//should pk in this parent?
	    		if ( model.getPk() == pk ) {
		    			l.add( model );
		    			return l;
	    		}
    		} else { //search in next tree segment.
 				List l1 = findModelPath( model.listOfChilds(), pk, depth-1 );
				if ( l1 != null ) {
					l.add( model );
					l.addAll( l1 );
					return l;
				}
     		}
    	}
    	return null;
    }
    
    
	/**
	 * @param src
	 * @return
	 */
	private Set getStickies(int mode) {
		switch (mode) {
			case PATIENT:
				return folderForm.getStickyPatients();
			case STUDY:
				return folderForm.getStickyStudies();
			case SERIES:
				return folderForm.getStickySeries();
			case INSTANCE:
				return folderForm.getStickyInstances();
		}
		return null;
	}
	
	
}
